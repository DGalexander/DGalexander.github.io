---
layout: post
subtitle: "Analysis of twitteR '#peakdistrict'"
date: "2016-04-09 14:18:00 +0800"
published: true
title: Quantifying visitor sentiment for a National Park
---
## Why access twitter?

Current **customer relationship management (CRM)** systems create customer profiles based on demographics, past buying patterns and other interactions or actions. Monitoring and quantifying interactions of customers with large areas of landscape such as National Parks with regular comprehensive visitor surveying is costly and prohibitively expensive. 

The emergance of both **social media mining (SMM)**, other data scienece methods and applications have provided us with the tools to access this information. This provides a great opportunity to develop CRM knowledge and monitoring. 

SMM is not without it's limitations. Preprocessing steps are required to remove the noise and error from the data. Due to the clutter, which is present in most unstructured data, removing the noise from data is difficult and not always sucesful. For the purpose of this analysis, not all tweets will contain sentiment, for example these could be factual or nonsensical.

## How is this done?

Created and app at <https://dev.twitter.com/apps> to access and reqest information from the Twitter
API. The _ROAuth_ package in R is used to allow the third party app to access the Twitter API.

The analysis then follows these steps:
1. Search and Clean Tweets
2. Estimate Sentiment (_Naive Algorithm_)
3. Estimate Sentiment (_Naive Bayes_)

## Search and Clean Tweets

For the purposes of obtainging sentiment of Twitter users we must gather data based on the term
'#peakdistrict'. 

'PDNP_Tweets = searchTwitter("peakdistrict", n = 10000, lang="en")'

Tweets returned are cleaned (4519 observations) based on following perameters (which provide 1310 
observations):

* Meta information usch as @people, URLs and #hashtags
* Punctuation marks, numbers and unnecessary spaces
* retweets (**RT**) not useful for sentiment analysis

## Estimating Sentiment

As mentioned earlier, some Tweets will be , factual, nonesenical or specific such as customer care
resonses. This analysis has not attempted to remove tweets from the data. 

### _Naive Algorithm_ 

The Naive algorithm gives a score based on the number of times a postive of negative word occured
in the given sentence (or Tweet). To do this, the positive and negative _opinion lexicon_ is 
[downloaded](http://www.cs.uic.edu/~liub/FBS/opinion-lexicon-English.rar). This is based on nearly 
68,000 words from the English Language and words categorised to be positive or negative.

Using a simple matching algorithm a _sentiment score_ can be computed. This boolean match of each
word is done for each Tweet, the total positive sentiment score minus the total negative sentiment 
score.

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>ColumnChartID13782f3a7915</title>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<style type="text/css">
body {
  color: #444444;
  font-family: Arial,Helvetica,sans-serif;
  font-size: 75%;
  }
  a {
  color: #4D87C7;
  text-decoration: none;
}
</style>
</head>
<body>
 <!-- ColumnChart generated in R 3.1.2 by googleVis 0.5.10 package -->
<!-- Fri May 06 16:48:06 2016 -->


<!-- jsHeader -->
<script type="text/javascript">
 
// jsData 
function gvisDataColumnChartID13782f3a7915 () {
var data = new google.visualization.DataTable();
var datajson =
[
 [
 "-3",
4 
],
[
 "-2",
6 
],
[
 "-1",
81 
],
[
 "0",
553 
],
[
 "1",
347 
],
[
 "2",
113 
],
[
 "3",
21 
] 
];
data.addColumn('string','Var1');
data.addColumn('number','Freq');
data.addRows(datajson);
return(data);
}
 
// jsDrawChart
function drawChartColumnChartID13782f3a7915() {
var data = gvisDataColumnChartID13782f3a7915();
var options = {};
options["allowHtml"] = true;
options["legend"] = "none";
options["width"] =    750;
options["height"] =    400;


    var chart = new google.visualization.ColumnChart(
    document.getElementById('ColumnChartID13782f3a7915')
    );
    chart.draw(data,options);
    

}
  
 
// jsDisplayChart
(function() {
var pkgs = window.__gvisPackages = window.__gvisPackages || [];
var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
var chartid = "corechart";
  
// Manually see if chartid is in pkgs (not all browsers support Array.indexOf)
var i, newPackage = true;
for (i = 0; newPackage && i < pkgs.length; i++) {
if (pkgs[i] === chartid)
newPackage = false;
}
if (newPackage)
  pkgs.push(chartid);
  
// Add the drawChart function to the global list of callbacks
callbacks.push(drawChartColumnChartID13782f3a7915);
})();
function displayChartColumnChartID13782f3a7915() {
  var pkgs = window.__gvisPackages = window.__gvisPackages || [];
  var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
  window.clearTimeout(window.__gvisLoad);
  // The timeout is set to 100 because otherwise the container div we are
  // targeting might not be part of the document yet
  window.__gvisLoad = setTimeout(function() {
  var pkgCount = pkgs.length;
  google.load("visualization", "1", { packages:pkgs, callback: function() {
  if (pkgCount != pkgs.length) {
  // Race condition where another setTimeout call snuck in after us; if
  // that call added a package, we must not shift its callback
  return;
}
while (callbacks.length > 0)
callbacks.shift()();
} });
}, 100);
}
 
// jsFooter
</script>
 
<!-- jsChart -->  
<script type="text/javascript" src="https://www.google.com/jsapi?callback=displayChartColumnChartID13782f3a7915"></script>
 
<!-- divChart -->
  
<div id="ColumnChartID13782f3a7915" 
  style="width: 750; height: 400;">
</div>
 <div><span>Data: data &#8226; Chart ID: <a href="Chart_ColumnChartID13782f3a7915.html">ColumnChartID13782f3a7915</a> &#8226; <a href="https://github.com/mages/googleVis">googleVis-0.5.10</a></span><br /> 
<!-- htmlFooter -->
<span> 
  R version 3.1.2 (2014-10-31) 
  &#8226; <a href="https://developers.google.com/terms/">Google Terms of Use</a> &#8226; <a href="https://google-developers.appspot.com/chart/interactive/docs/gallery/columnchart">Documentation and Data Policy</a>
</span></div>
</body>
</html>


From the observations, it is clear this 

### _Naive Bayes_

One of the key problems of analytics is to classify entities or events based on a knowledge of their 
attributes. Rather than a simple matching of opinion lexicon, the [_Naive Bayes_](https://en.wikipedia.org/wiki/Bayes%27_theorem)
method helps decide on and classify a series of emotionions present in each Tweet.This uses the 
'Rstem' and 'Sentiment' package. The 'Sentiment' package was built to use a _trained_ dataset of
emotion words (approximatley 1,500). Results can then be generated belonging to one of six emotions:
**anger**, **disgust**, **fear**, **joy**, **sadness** and **surprise**. Not all tweets will contain
data to fit these categories and get disregarded from the analysis.

<!-- Histogram generated in R 3.1.2 by googleVis 0.5.6 package -->
<!-- Wed Jan 14 17:22:44 2015 -->


<!-- jsHeader -->
<script type="text/javascript">
 
// jsData 
function gvisDataHistogramID156f55ce9311 () {
var data = new google.visualization.DataTable();
var datajson =
[
 [
 21 
],
[
 21 
],
[
 22.8 
],
[
 21.4 
],
[
 18.7 
],
[
 18.1 
],
[
 14.3 
],
[
 24.4 
],
[
 22.8 
],
[
 19.2 
],
[
 17.8 
],
[
 16.4 
],
[
 17.3 
],
[
 15.2 
],
[
 10.4 
],
[
 10.4 
],
[
 14.7 
],
[
 32.4 
],
[
 30.4 
],
[
 33.9 
],
[
 21.5 
],
[
 15.5 
],
[
 15.2 
],
[
 13.3 
],
[
 19.2 
],
[
 27.3 
],
[
 26 
],
[
 30.4 
],
[
 15.8 
],
[
 19.7 
],
[
 15 
],
[
 21.4 
] 
];
data.addColumn('number','mpg');
data.addRows(datajson);
return(data);
}
 
// jsDrawChart
function drawChartHistogramID156f55ce9311() {
var data = gvisDataHistogramID156f55ce9311();
var options = {};
options["allowHtml"] = true;
options["hAxis"] = {title:'mpg'};
options["width"] =    450;
options["height"] =    300;

    var chart = new google.visualization.Histogram(
    document.getElementById('HistogramID156f55ce9311')
    );
    chart.draw(data,options);
    

}
  
 
// jsDisplayChart
(function() {
var pkgs = window.__gvisPackages = window.__gvisPackages || [];
var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
var chartid = "corechart";
  
// Manually see if chartid is in pkgs (not all browsers support Array.indexOf)
var i, newPackage = true;
for (i = 0; newPackage && i < pkgs.length; i++) {
if (pkgs[i] === chartid)
newPackage = false;
}
if (newPackage)
  pkgs.push(chartid);
  
// Add the drawChart function to the global list of callbacks
callbacks.push(drawChartHistogramID156f55ce9311);
})();
function displayChartHistogramID156f55ce9311() {
  var pkgs = window.__gvisPackages = window.__gvisPackages || [];
  var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
  window.clearTimeout(window.__gvisLoad);
  // The timeout is set to 100 because otherwise the container div we are
  // targeting might not be part of the document yet
  window.__gvisLoad = setTimeout(function() {
  var pkgCount = pkgs.length;
  google.load("visualization", "1", { packages:pkgs, callback: function() {
  if (pkgCount != pkgs.length) {
  // Race condition where another setTimeout call snuck in after us; if
  // that call added a package, we must not shift its callback
  return;
}
while (callbacks.length > 0)
callbacks.shift()();
} });
}, 100);
}
 
// jsFooter
</script>
 
<!-- jsChart -->  
<script type="text/javascript" src="https://www.google.com/jsapi?callback=displayChartHistogramID156f55ce9311"></script>
 
<!-- divChart -->
  
<div id="HistogramID156f55ce9311" 
  style="width: 450; height: 300;">
</div>
